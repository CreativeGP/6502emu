# CPUã®ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã‚’ä½œã‚‹

ã©ã†ã‚‚ï¼ã©ã†ã‚‚ï¼ï¼ï¼

ä»Šå›ã¯CPUã®ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã‚’ä½œã‚‹å›ã§ã™ã€‚ä½ãƒ¬ã‚¤ãƒ¤ã®å‹‰å¼·ã®ãŸã‚ã«æœ€åˆã«ç°¡å˜ãªã‚¨ãƒŸãƒ¥ã‚’æ›¸ã“ã†ã‹ãªã¨æ€ã„ã¾ã™ã€‚ä»Šå›åƒ­è¶Šã«ã‚‚ã‚¨ãƒŸãƒ¥ã‚‰ã›ã¦ã„ãŸã ãCPUã¯ã€**6502**ã§ã™ã€‚ç†ç”±ã¯NESã«ä½¿ã‚ã‚Œã¦ã„ã‚‹ã‚‰ã—ã„ã‹ã‚‰ã§ã™ï¼ˆç•Œéšˆã§ã¯æœ‰åãªã‚“ã§ã™ã‹ã€6502ï¼Ÿï¼‰ã€‚



## åŸºæœ¬çš„ãªæƒ…å ±

ã¾ãšã¯ã‚¨ãƒŸãƒ¥ã‚‹CPUã®æƒ…å ±ã‚’é›†ã‚ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚

åƒ•ã¯[Wikipedia](https://en.wikipedia.org/wiki/MOS_Technology_6502)ã—ã‹è¦‹ã¾ã›ã‚“ã§ã—ãŸï¼ˆï¼‰



## å¤§ã¾ã‹ãªæµã‚Œ

[http://fms.komkon.org/EMUL8/HOWTO.html#LABG](http://fms.komkon.org/EMUL8/HOWTO.html#LABG)

ã“ã“ã‚’è¦‹ã‚‹ã¨å¤§ä½“å‡ºæ¥ã‚‹ã®ã§ã™ãŒã€ã“ã“ã‹ã‚‰å¼•ç”¨ã—ã¾ã™ã€‚

```c
Counter=InterruptPeriod;
PC=InitialPC;

for(;;)
{
  OpCode=Memory[PC++];
  Counter-=Cycles[OpCode];

  switch(OpCode)
  {
    case OpCode1:
    case OpCode2:
    ...
  }

  if(Counter<=0)
  {
    /* Check for interrupts and do other */
    /* cyclic tasks here                 */
    ...
    Counter+=InterruptPeriod;
    if(ExitRequired) break;
  }
}
```

ç„¡é™ãƒ«ãƒ¼ãƒ—ã®ä¸­ã§ã€æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã‚’èª­ã‚“ã§ã€å¿…è¦ã‚µã‚¤ã‚¯ãƒ«ã‚«ã‚¦ãƒ³ã‚¿ã‚’æ¸›ã‚‰ã—ã¦ã€åƒã„ã¦ã€å‰²ã‚Šè¾¼ã¿ã¨ã‹ã‚’å‡¦ç†ã™ã‚‹ã€ã£ã¦æ„Ÿã˜ã§ã™ã€‚



## ã„ã–ã€æ›¸ã

Emacsã‚’ã‚¹ãƒãƒ£ãƒƒã¨ç«‹ã¡ä¸Šã’ã¦ä¸æ„ã«æ¬¡ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãã¾ã™ã€‚

```C
/*
  6502 CPU Emulator

  Author: Creative GP
  2018/11/27
  My first emulator!
 */

#include <stdio.h>

int main(int argc, char *argv[], char *envp[])
{
    
}

```

envpã¯ãªã‚“ã‹ã‚«ãƒƒã‚³ã„ã„ã®ã§ä»˜ã‘ã¾ã—ãŸã€‚ç’°å¢ƒæƒ…å ±ãŒå…¥ã£ã¦ãã‚‹ã‚‰ã—ã„ã§ã™ã€‚åƒ•ã®ç’°å¢ƒã§ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªæ–‡å­—åˆ—ï¼‘ã¤ã ã‘ã—ã‹å…¥ã£ã¦ã„ã¾ã›ã‚“ã§ã—ãŸã€‚

```
PWD=/home/cgp/Develop/cpuemu/6502
```

å®Ÿè¡Œã—ãŸãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ã™ã­ã€‚



ã¾ãã“ã‚“ãªã‚‚ã®ã¯è‰¯ãã¦ã€ã¾ãšã¯ãƒ¡ãƒ¢ãƒªã‚’ã©ã†ã«ã‹ã—ã¾ã—ã‚‡ã†ã€‚



## ãƒ¡ãƒ¢ãƒªã‚’ã©ã†ã«ã‹ã™ã‚‹

ã¾ãšã¯ãƒ¡ãƒ¢ãƒªã«ã¤ã„ã¦æ·±ãèª¿ã¹ã¦ã¿ã¾ã™ã€‚

6502ã®å ´åˆã‚¢ãƒ‰ãƒ¬ã‚¹ã¯16-bitãªã®ã§ã€ãƒ¡ãƒ¢ãƒªã®é‡ã¯$2^{16} =65536$ãƒã‚¤ãƒˆã§ã™ã€‚



> **Zero Page**
>
> 6502ãªã©è¨ˆç®—ç”¨ãƒ¬ã‚¸ã‚¹ã‚¿ãŒå°‘ãªã„CPUã§ã¯ã€è¨ˆç®—ã®ãŸã‚ã«ãƒ¡ãƒ¢ãƒªã‚’ç›´æ¥ä½¿ã†ã“ã¨ãŒè‰¯ãã‚ã‚‹ã€‚è‰¯ãã‚ã‚‹ã®ã§ã€ç•ªåœ°ãŒé•·ã™ãã‚‹ã¨å«Œã ã€‚ãªã®ã§ã€#00xx -> #xx, #000x -> #xã¨æ›¸ã‘ã‚‹ã‚ˆã†ã«ã—ã‚ˆã†ï¼çš„ãªãƒãƒªã®ãƒ¢ãƒ¼ãƒ‰ã‚‰ã—ã„ã§ã™ã€‚ãªã®ã§ã€#0000 ~ #00FFãŒæ²¢å±±åˆ©ç”¨ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã§é«˜é€ŸåŒ–ã•ã‚Œã‚‹ã‚‰ã—ã„ã€‚



ã‚³ãƒ¼ãƒ‰ã¨ã—ã¦ã¯ã“ã‚“ãªæ„Ÿã˜ã§ã¨ã‚Šã‚ãˆãšæ›¸ã„ã¦ã¿ã‚‹ã€ã€

```C
int main(int argc, char *argv[], char *envp[])
{
    mem = calloc(1, 65536);
    if (!mem)
    {
        printf("faild memory allocation");
        return -1;
    }

    u8 A, X, Y, S;
    u16 PC;
    union
    {
        unsigned int P: 7;
        struct
        {
            unsigned int C: 1;
            unsigned int Z: 1;
            unsigned int I: 1;
            unsigned int D: 1;
            unsigned int B: 1;
            unsigned int O: 1;
            unsigned int N: 1;
        } flags;
    } reg;


    for (;;)
    {
        
    }

    free(mem);

    return 0;
}

```

ãƒ¡ãƒ¢ãƒªã®å‰²ã‚Šå½“ã¦ã«ã¤ã„ã¦ã¯ã“ã‚Œã˜ã‚ƒé§„ç›®çš„ãªè¨˜è¿°ãŒã‚ã£ãŸæ°—ãŒã™ã‚‹ã‚“ã ã‘ã©ã€ç†ç”±ã‚’èª­ã‚“ã§ã‚‚è‰¯ãåˆ†ã‚‰ãªã‹ã£ãŸã®ã§æ™®é€šã«å®Ÿè£…ã—ãŸã€‚



## ãƒ—ãƒ­ã‚°ãƒ©ãƒ å®Ÿè¡Œéƒ¨åˆ†ã‚’æ›¸ã

ãƒ—ãƒ­ã‚°ãƒ©ãƒ å®Ÿè¡Œéƒ¨åˆ†ã‚’æ›¸ã„ã¦ã„ãã€‚ã¨ã‚Šã‚ãˆãšæœ€åˆã«ã€PCã®åˆæœŸåŒ–ã¨å¯¿å‘½ã‚’æ±ºã‚ã‚‹å¿…è¦ãŒã‚ã‚‹ã‚‰ã—ã„ã€‚

PCã®åˆæœŸå€¤ã¯[ã“ã“ã‚‰ã¸ã‚“](http://forum.6502.org/viewtopic.php?t=1708)ã‚’è¦‹ã‚‹ã¨ã€#[#FFFD#FFFC]ã«ãªã‚‰ãªã‘ã‚Œã°ãªã‚‰ãªã„ã¨æ›¸ã„ã¦ã‚ã‚‹ï¼ˆreset vectorã¨ã„ã†ã‚‰ã—ã„ï¼‰ã€‚ç´ ç›´ã«ã‚„ã‚‹ã‘ã©ã“ã“ã‚‰ã¸ã‚“ã¯ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã§ã‚‚èª¿æ•´ã§ãã‚‹ã‚ˆã†ã«ã—ãªãã‚ƒã‹ã‚‚ã—ã‚Œãªã„ã€‚

```c
u64 count = UINT64_MAX;
PC = mem[0xFFFD]<<8 + mem[0xFFFC];
```



## ã‚ªãƒšã‚³ãƒ¼ãƒ‰è§£èª­å¤§ä¼š ğŸ§ 

ã“ã“ã‚‰è¾ºã¯[ã“ã‚Œ](https://www.masswerk.at/6502/6502_instruction_set.html)ã‚’è–æ›¸ã®ã‚ˆã†ã«ç†Ÿèª­ã—ãªãŒã‚‰æ›¸ã„ã¦ã„ãã‚ã‘ã§ã™ã€‚

ã¾ãšã€ç„¡ç§©åºã«ä¸¦ã‚“ã§ã„ã‚‹ã‚ˆã†ãªã‚ªãƒšã‚³ãƒ¼ãƒ‰é”ã¯å®Ÿã¯è‹¥å¹²ã®è¦å‰‡ãŒã‚ã‚‹ã‚ˆã£ã¦ã„ã†è©±ãŒæœ€å¾Œã‚‰ã¸ã‚“ã«æ›¸ã„ã¦ã‚ã‚‹ã®ã§ã€ãã‚Œã‚’åˆ©ç”¨ã—ãªãŒã‚‰åŠ¹ç‡çš„ã«ã‚ªãƒšã‚³ãƒ¼ãƒ‰è§£èª­ã€ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã®å±•é–‹ãªã©ã‚‚ã‚„ã£ã¦ã„ãã¾ã™ã€‚

ã‚ªãƒšã‚³ãƒ¼ãƒ‰ã‚’ãƒã‚¤ãƒŠãƒªã§ä¸¦ã¹ã¦"aaabbbcc"ã§å„æ–‡å­—ã®ä½ç½®ã«æ¥ã‚‹ãƒã‚¤ãƒŠãƒªã‚’åŒºåˆ‡ã£ã¦èª­ã‚“ã æ™‚ã«[^1]ã€bã¯ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã®å±•é–‹æ–¹æ³•ã‚’**å¤§ä½“**è¡¨ã—ã¦ã„ã¦ã€a,cã¯ã‚ªãƒšã‚³ãƒ¼ãƒ‰ã‚’**å¤§ä½“**è¡¨ã—ã¦ã„ã‚‹ã¨ã„ã†è¦å‰‡ãŒã‚ã‚Šã¾ã™ã€‚

```c
u8 a = (op & 0b11100000) >> 5;
u8 b = (op &    0b11100) >> 2;
u8 c = (op &       0b11);
```



æ¬¡ã¯ã€ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã®å±•é–‹ã‚’ã‚„ã‚Šã¾ã™ã€‚

|    b | ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã®å±•é–‹æ–¹æ³• |
| ---: | :------------------- |
|    0 | X,ind                |
|    1 | zpg                  |
|    2 | #                    |
|    3 | abs                  |
|    4 | ind,Y                |
|    5 | zpg,X                |
|    6 | abs,Y                |
|    7 | abs,X                |

bã«ã‚ˆã£ã¦ã“ã®ã‚ˆã†ã«æ±ºã¾ã£ã¦ã„ã¾ã™ã€‚ã¾ãŸã€å„å±•é–‹æ–¹æ³•ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªæ„Ÿã˜ã§ã™ã€‚ï¼ˆãƒ¬ã‚¸ã‚¹ã‚¿åã ã‘ã‚’è¨˜è¿°ã—ã¦ã„ã‚‹ã¨ã“ã‚ã¯ã€ãƒ¬ã‚¸ã‚¹ã‚¿åã®å€¤ã‚’è¡¨ã—ã¦ã„ã¾ã™ï¼‰

| è­˜åˆ¥å­ | åå‰                 | ã‚¢ã‚»ãƒ³ãƒ–ãƒª | æ„å‘³                                                    |
| ------ | -------------------- | ---------- | ------------------------------------------------------- |
| A      | Accumulator          | A          | å€¤AãŒã‚ªãƒšãƒ©ãƒ³ãƒ‰                                         |
| abs    | absolute             | $LLHH      | *$LLHH*ç•ªåœ°ãŒã‚ªãƒšãƒ©ãƒ³ãƒ‰                                 |
| abs,X  | absolute, X-indexed  | $LLHH,X    | *$LLHH+X*ç•ªåœ°ãŒã‚ªãƒšãƒ©ãƒ³ãƒ‰                               |
| abs,Y  | absolute, Y-indexed  | $LLHH,Y    | *$LLHH+Y*ç•ªåœ°ãŒã‚ªãƒšãƒ©ãƒ³ãƒ‰                               |
| #      | immediate            | #$BB       | å€¤BBãŒã‚ªãƒšãƒ©ãƒ³ãƒ‰                                        |
| impl   | implied              |            | ã‚ªãƒšãƒ©ãƒ³ãƒ‰ç„¡ã—                                          |
| ind    | indirect             | ($LLHH)    | *$LLHHç•ªåœ°ã®å€¤ã‚’***16-bitã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ã—ã¦**ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã«   |
| X,ind  | X-indexed, indirect  | ($LL,X)    | *$00LL+Xç•ªåœ°ã®å€¤ã‚’***16-bitã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ã—ã¦**ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã« |
| ind,Y  | indirect, Y-indexed  | ($LL),Y    | *$00LLç•ªåœ°ã®å€¤**+Y**ã‚’*16-bitã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ã—ã¦ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã« |
| rel    | relative             | $BB        | åˆ†å²å…ˆã¯$BB+PC                                          |
| zpg    | zero page            | $LL        | $00LLç•ªåœ°ãŒã‚ªãƒšãƒ©ãƒ³ãƒ‰                                   |
| zpg,X  | zero page, X-indexed | $LL,X      | $00LL+Xç•ªåœ°ãŒã‚ªãƒšãƒ©ãƒ³ãƒ‰                                 |
| zpg,Y  | zero page, Y-indexed | $LL,Y      | $00LL+Yç•ªåœ°ãŒã‚ªãƒšãƒ©ãƒ³ãƒ‰                                 |

ã¡ã‚‡ã£ã¨ã‚„ã‚„ã“ã—ã„éƒ¨åˆ†ã‚‚ã‚ã‚Šã¾ã™ã­ã€‚

å¾Œç•™æ„ã‚¹ã¹ãç‚¹ã¨ã—ã¦ã¯ã€

> 
>
>**Â  The available 16-bit address space is conceived as consisting of pages of 256 bytes each, with  address hi-bytes represententing the page index. An increment with carry may affect the hi-byte  and may thus result in a crossing of page boundaries, adding an extra cycle to the execution.  Increments without carry do not affect the hi-byte of an address and no page transitions do occur.  Generally, increments of 16-bit addresses include a carry, increments of zeropage addresses don't.

è¡¨ã§Xã‚„Yã§è¶³ã—ç®—ã‚’ã™ã‚‹ã¨ã“ã‚ã®è©±ã§ã™ã€‚å®Ÿéš›ã®ãƒ¡ãƒ¢ãƒªã¯256byteæ¯ã«ãƒšãƒ¼ã‚¸ã¨ã„ã†å˜ä½ã§åŒºåˆ‡ã‚‰ã‚Œã¦ã„ã¦ã€è¶³ã—ç®—ã‚’ã™ã‚‹ã¨ãƒšãƒ¼ã‚¸å¢ƒç•Œã‚’è¶…ãˆã¦ã—ã¾ã†ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚é€šå¸¸ã¯ç¹°ã‚Šä¸ŠãŒã‚Šæœ‰ã‚Šã§ã€ã‚¼ãƒ­ãƒšãƒ¼ã‚¸ã®å ´åˆã¯ç¹°ã‚Šä¸ŠãŒã‚Šãªã—ã§å®Ÿè£…ã—ã¦ãã ã•ã„ã€ã¨ã„ã†ã“ã¨ã§ã—ã‚‡ã†ã‹ã€‚ã¨ã„ã†ã“ã¨ã§ã€X,indã€ind,Yã€zpg,Xã€zpg,Yã¯ç¹°ã‚Šä¸ŠãŒã‚Šç„¡ã—ã§å®Ÿè£…ã—ã¾ã™ã€‚

```c
u16 tmppc = PC++;
u16 operand = 0;

#define LLHH(l, h) l + h<<8
#define CUT(x) (x)&0xFF
#define LOAD16(x) LLHH(mem[x],mem[x+1])
switch (b) {
	case 0: operand = LOAD16(mem[CUT(tmppc+X)]); break;       // X,ind
	case 1: operand = mem[tmppc]; break;                      // zpg
	case 2: operand = mem[tmppc]; break;                      // #
	case 3: operand = LLHH(mem[tmppc], mem[PC++]); break;     // abs
	case 4: operand = LOAD16(CUT(mem[tmppc]+Y)); break;       // ind,Y
	case 5: operand = CUT(mem[tmppc]+X); break;               // zpg,X
	case 6: operand = LLHH(mem[tmppc], mem[PC++]) + X; break; // abs,Y
	case 7: operand = LLHH(mem[tmppc], mem[PC++]) + X; break; // abs,X
}
```

æ…é‡ã«ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã‚’å±•é–‹ã—ã¦ã€ã€

```c
switch (c) {
    case 0:
        switch (a) {
            case 5: goto LDY;
            case 6: goto CPY;
            case 7: goto CPX;
        }
        break;
    case 1:
        switch (a) {
            case 0: goto ORA;
            case 1: goto AND;
            case 2: goto EOR;
            case 3: goto ADC;
            case 4: goto STA;
            case 5: goto LDA;
            case 6: goto CMP;
            case 7: goto SBC;
        }
        break;
    case 2:
        switch (a) {
            case 0: goto ASL;
            case 1: goto ROL;
            case 2: goto LSR;
            case 3: goto ROR;
            case 4: goto STX;
            case 5: goto LDX;
            case 6: goto DEC;
            case 7: goto INC;
        }
        break;
}
```

a, cã§å„å‘½ä»¤ã®å‡¦ç†éƒ¨åˆ†ã«é£›ã°ã—ã¾ã™ã€‚ä¾‹å¤–ã‚‚çµæ§‹ã‚ã‚‹ã®ã§ã™ãŒã€ãã‚Œã‚‰ã¯ä½™è¨ˆãªè¨ˆç®—ã‚’ã—ãªãã¦è‰¯ã„ã‚ˆã†ã«ã‚¢ãƒ‰ãƒ¬ã‚¹è¨ˆç®—ã®å‰ã«å€‹åˆ¥ã«é£›ã°ã—ã¦ãŠãã¾ã™ã€‚

## å„å‘½ä»¤ã®å®Ÿè£…ã§è‹¥å¹²è¿·ã£ãŸã¨ã“ã‚ã¨ã‹

Carry flagã¨Negative flagã®æ›´æ–°ã«å›°ã‚Šã¾ã—ãŸã€‚

http://teaching.idallen.com/dat2343/10f/notes/040_overflow.txt



## å®Ÿéš›ã«å‹•ã‹ã—ã¦ã¿ãŸã„

å‘½ä»¤ã®å®Ÿè£…ã€ã‚µã‚¤ã‚¯ãƒ«æ•°ã®æ‰“ã¡è¾¼ã¿ç­‰ãŒã§ããŸã®ã§ã€å®Ÿéš›ã«å‹•ã‹ã—ã¦ã¿ãŸã„ã‚ã‘ã§ã™ãŒã€ã¡ã‚‡ã£ã¨å¾…ã£ã¦ä¸‹ã•ã„ã€**ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã£ã¦ä½•å‡¦ã«æ ¼ç´ã•ã‚Œã‚‹ã‚“ã§ã™ã‹ï¼Ÿ**

ã¡ã‚‡ã£ã¨èª¿ã¹ã¦ã¿ã‚‹ã¨ã€ã©ã“ã§ã‚‚è‰¯ã„ã¿ãŸã„...ï¼Ÿ

$00-ff = zero page  

$100-1ff = stack  

$FFFA-FFFB - NMI vector  

$FFFC-FFFD - RESET vector  

$FFFE-FFFF - IRQ/BRK vector

ã©ã“ã§ã‚‚è‰¯ã„ãªã‚‰ã¨ã‚Šã‚ãˆãšã€0x0200ã‹ã‚‰ã‚³ãƒ”ãƒ¼ã—ã¦ç½®ã„ã¦ã„ãã¾ã™ã‹ã€ã€ã€[^2]

ã‚ã¨ã€ãƒ†ã‚¹ãƒˆãƒã‚¤ãƒŠãƒªãŒå¿…è¦ã§ã™ã€‚é©å½“ãªã‚¢ã‚»ãƒ³ãƒ–ãƒªã‚’æ›¸ã„ã¦èª­ã¾ã›ãŸã„ã®ã§ã€ã¾ãšã¯6502å°‚ç”¨ã®ã‚¢ã‚»ãƒ³ãƒ–ãƒ©ã‚’æ›¸ã“ã†ã¨æ€ã„ã¾ã™ã€‚



## ã‚¢ã‚»ãƒ³ãƒ–ãƒ©ã‚’æ›¸ã

ç°¡å˜ãªã‚‚ã®ã‚’Pythonã§æ›¸ãã¾ã—ãŸã€‚



## Notes

[^1]: ä½•ã‚’è¨€ã£ã¦ã„ã‚‹ã‹ã‚ã‹ã‚‰ãªã„ã¨æ€ã„ã¾ã™ã€‚ä¾‹ãŒæ—©ã„ã¨æ€ã„ã¾ã™ã€‚ä¾‹ãˆã°ã€ã‚ªãƒšã‚³ãƒ¼ãƒ‰ãŒäºŒé€²æ•°ã§01101001ã ã£ãŸå ´åˆã¯011'010'01ã§åˆ†å‰²ã—ã¦a=011,b=010,c=01ã¨ã™ã‚‹ã‚ˆï¼ã£ã¦ã„ã†ã“ã¨ã§ã™ã€‚
[^2]: http://hp.vector.co.jp/authors/VA042397/nes/adrmap.htmlã€€ã‚³ã‚³ã‚‰ã¸ã‚“ã‚’è¦‹ã‚‹ã¨$8000ã£ã¦æ›¸ã„ã¦ã‚ã‚‹ã‹ã‚‰ãã†ã—ã¾ã—ãŸ



**é›†ã‚ã‚‰ã‚ŒãŸæƒ…å ±** 

ãƒ»å‘½ä»¤ã¯little-endianã§1-byte

ãƒ»ç•ªåœ°ã¯2-byte

ãƒ»ãƒ¬ã‚¸ã‚¹ã‚¿

ãƒ»A  (8-bit) è¨ˆç®—ç”¨

ãƒ»X, Y (8-bit) ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹

ãƒ»SP (8-bit) ã‚¹ã‚¿ãƒƒã‚¯ãƒã‚¤ãƒ³ã‚¿

ãƒ»PC (16-bit) ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚«ã‚¦ãƒ³ã‚¿

ãƒ»P (7-bit) CZIDB\ON

ãƒ»ã“ã‚Œã‚‰ãƒ¬ã‚¸ã‚¹ã‚¿ã¯$01